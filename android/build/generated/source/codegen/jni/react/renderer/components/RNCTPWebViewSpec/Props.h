
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <cinttypes>
#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

enum class RNCTPWebViewAndroidLayerType { None, Software, Hardware };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewAndroidLayerType &result) {
  auto string = (std::string)value;
  if (string == "none") { result = RNCTPWebViewAndroidLayerType::None; return; }
  if (string == "software") { result = RNCTPWebViewAndroidLayerType::Software; return; }
  if (string == "hardware") { result = RNCTPWebViewAndroidLayerType::Hardware; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewAndroidLayerType &value) {
  switch (value) {
    case RNCTPWebViewAndroidLayerType::None: return "none";
    case RNCTPWebViewAndroidLayerType::Software: return "software";
    case RNCTPWebViewAndroidLayerType::Hardware: return "hardware";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewAndroidLayerType &value) {
  return toString(value);
}
#endif
enum class RNCTPWebViewCacheMode { LOAD_DEFAULT, LOAD_CACHE_ELSE_NETWORK, LOAD_NO_CACHE, LOAD_CACHE_ONLY };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewCacheMode &result) {
  auto string = (std::string)value;
  if (string == "LOAD_DEFAULT") { result = RNCTPWebViewCacheMode::LOAD_DEFAULT; return; }
  if (string == "LOAD_CACHE_ELSE_NETWORK") { result = RNCTPWebViewCacheMode::LOAD_CACHE_ELSE_NETWORK; return; }
  if (string == "LOAD_NO_CACHE") { result = RNCTPWebViewCacheMode::LOAD_NO_CACHE; return; }
  if (string == "LOAD_CACHE_ONLY") { result = RNCTPWebViewCacheMode::LOAD_CACHE_ONLY; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewCacheMode &value) {
  switch (value) {
    case RNCTPWebViewCacheMode::LOAD_DEFAULT: return "LOAD_DEFAULT";
    case RNCTPWebViewCacheMode::LOAD_CACHE_ELSE_NETWORK: return "LOAD_CACHE_ELSE_NETWORK";
    case RNCTPWebViewCacheMode::LOAD_NO_CACHE: return "LOAD_NO_CACHE";
    case RNCTPWebViewCacheMode::LOAD_CACHE_ONLY: return "LOAD_CACHE_ONLY";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewCacheMode &value) {
  return toString(value);
}
#endif
enum class RNCTPWebViewMixedContentMode { Never, Always, Compatibility };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewMixedContentMode &result) {
  auto string = (std::string)value;
  if (string == "never") { result = RNCTPWebViewMixedContentMode::Never; return; }
  if (string == "always") { result = RNCTPWebViewMixedContentMode::Always; return; }
  if (string == "compatibility") { result = RNCTPWebViewMixedContentMode::Compatibility; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewMixedContentMode &value) {
  switch (value) {
    case RNCTPWebViewMixedContentMode::Never: return "never";
    case RNCTPWebViewMixedContentMode::Always: return "always";
    case RNCTPWebViewMixedContentMode::Compatibility: return "compatibility";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewMixedContentMode &value) {
  return toString(value);
}
#endif
enum class RNCTPWebViewContentInsetAdjustmentBehavior { Never, Automatic, ScrollableAxes, Always };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewContentInsetAdjustmentBehavior &result) {
  auto string = (std::string)value;
  if (string == "never") { result = RNCTPWebViewContentInsetAdjustmentBehavior::Never; return; }
  if (string == "automatic") { result = RNCTPWebViewContentInsetAdjustmentBehavior::Automatic; return; }
  if (string == "scrollableAxes") { result = RNCTPWebViewContentInsetAdjustmentBehavior::ScrollableAxes; return; }
  if (string == "always") { result = RNCTPWebViewContentInsetAdjustmentBehavior::Always; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewContentInsetAdjustmentBehavior &value) {
  switch (value) {
    case RNCTPWebViewContentInsetAdjustmentBehavior::Never: return "never";
    case RNCTPWebViewContentInsetAdjustmentBehavior::Automatic: return "automatic";
    case RNCTPWebViewContentInsetAdjustmentBehavior::ScrollableAxes: return "scrollableAxes";
    case RNCTPWebViewContentInsetAdjustmentBehavior::Always: return "always";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewContentInsetAdjustmentBehavior &value) {
  return toString(value);
}
#endif
enum class RNCTPWebViewContentMode { Recommended, Mobile, Desktop };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewContentMode &result) {
  auto string = (std::string)value;
  if (string == "recommended") { result = RNCTPWebViewContentMode::Recommended; return; }
  if (string == "mobile") { result = RNCTPWebViewContentMode::Mobile; return; }
  if (string == "desktop") { result = RNCTPWebViewContentMode::Desktop; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewContentMode &value) {
  switch (value) {
    case RNCTPWebViewContentMode::Recommended: return "recommended";
    case RNCTPWebViewContentMode::Mobile: return "mobile";
    case RNCTPWebViewContentMode::Desktop: return "desktop";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewContentMode &value) {
  return toString(value);
}
#endif
using RNCTPWebViewDataDetectorTypesMask = uint32_t;

struct RNCTPWebViewDataDetectorTypesMaskWrapped {
  RNCTPWebViewDataDetectorTypesMask value;
};

enum class RNCTPWebViewDataDetectorTypes: RNCTPWebViewDataDetectorTypesMask {
  Address = 1 << 0,
  Link = 1 << 1,
  CalendarEvent = 1 << 2,
  TrackingNumber = 1 << 3,
  FlightNumber = 1 << 4,
  LookupSuggestion = 1 << 5,
  PhoneNumber = 1 << 6,
  All = 1 << 7,
  None = 1 << 8
};

constexpr bool operator&(
  RNCTPWebViewDataDetectorTypesMask const lhs,
  enum RNCTPWebViewDataDetectorTypes const rhs) {
  return lhs & static_cast<RNCTPWebViewDataDetectorTypesMask>(rhs);
}

constexpr RNCTPWebViewDataDetectorTypesMask operator|(
  RNCTPWebViewDataDetectorTypesMask const lhs,
  enum RNCTPWebViewDataDetectorTypes const rhs) {
  return lhs | static_cast<RNCTPWebViewDataDetectorTypesMask>(rhs);
}

constexpr void operator|=(
  RNCTPWebViewDataDetectorTypesMask &lhs,
  enum RNCTPWebViewDataDetectorTypes const rhs) {
  lhs = lhs | static_cast<RNCTPWebViewDataDetectorTypesMask>(rhs);
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewDataDetectorTypesMaskWrapped &wrapped) {
  auto items = std::vector<std::string>{value};
  for (const auto &item : items) {
    if (item == "address") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::Address;
      continue;
    }
    if (item == "link") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::Link;
      continue;
    }
    if (item == "calendarEvent") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::CalendarEvent;
      continue;
    }
    if (item == "trackingNumber") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::TrackingNumber;
      continue;
    }
    if (item == "flightNumber") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::FlightNumber;
      continue;
    }
    if (item == "lookupSuggestion") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::LookupSuggestion;
      continue;
    }
    if (item == "phoneNumber") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::PhoneNumber;
      continue;
    }
    if (item == "all") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::All;
      continue;
    }
    if (item == "none") {
      wrapped.value |= RNCTPWebViewDataDetectorTypes::None;
      continue;
    }
    abort();
  }
}

static inline std::string toString(const RNCTPWebViewDataDetectorTypesMaskWrapped &wrapped) {
    auto result = std::string{};
    auto separator = std::string{", "};

    if (wrapped.value & RNCTPWebViewDataDetectorTypes::Address) {
      result += "address" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::Link) {
      result += "link" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::CalendarEvent) {
      result += "calendarEvent" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::TrackingNumber) {
      result += "trackingNumber" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::FlightNumber) {
      result += "flightNumber" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::LookupSuggestion) {
      result += "lookupSuggestion" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::PhoneNumber) {
      result += "phoneNumber" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::All) {
      result += "all" + separator;
    }
    if (wrapped.value & RNCTPWebViewDataDetectorTypes::None) {
      result += "none" + separator;
    }
    if (!result.empty()) {
      result.erase(result.length() - separator.length());
    }
    return result;
}
enum class RNCTPWebViewMediaCapturePermissionGrantType { Prompt, Grant, Deny, GrantIfSameHostElsePrompt, GrantIfSameHostElseDeny };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewMediaCapturePermissionGrantType &result) {
  auto string = (std::string)value;
  if (string == "prompt") { result = RNCTPWebViewMediaCapturePermissionGrantType::Prompt; return; }
  if (string == "grant") { result = RNCTPWebViewMediaCapturePermissionGrantType::Grant; return; }
  if (string == "deny") { result = RNCTPWebViewMediaCapturePermissionGrantType::Deny; return; }
  if (string == "grantIfSameHostElsePrompt") { result = RNCTPWebViewMediaCapturePermissionGrantType::GrantIfSameHostElsePrompt; return; }
  if (string == "grantIfSameHostElseDeny") { result = RNCTPWebViewMediaCapturePermissionGrantType::GrantIfSameHostElseDeny; return; }
  abort();
}

static inline std::string toString(const RNCTPWebViewMediaCapturePermissionGrantType &value) {
  switch (value) {
    case RNCTPWebViewMediaCapturePermissionGrantType::Prompt: return "prompt";
    case RNCTPWebViewMediaCapturePermissionGrantType::Grant: return "grant";
    case RNCTPWebViewMediaCapturePermissionGrantType::Deny: return "deny";
    case RNCTPWebViewMediaCapturePermissionGrantType::GrantIfSameHostElsePrompt: return "grantIfSameHostElsePrompt";
    case RNCTPWebViewMediaCapturePermissionGrantType::GrantIfSameHostElseDeny: return "grantIfSameHostElseDeny";
  }
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewMediaCapturePermissionGrantType &value) {
  return toString(value);
}
#endif
struct RNCTPWebViewContentInsetStruct {
  double top{0.0};
  double left{0.0};
  double bottom{0.0};
  double right{0.0};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNCTPWebViewContentInsetStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["top"] = top;
    result["left"] = left;
    result["bottom"] = bottom;
    result["right"] = right;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewContentInsetStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
}

static inline std::string toString(const RNCTPWebViewContentInsetStruct &value) {
  return "[Object RNCTPWebViewContentInsetStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewContentInsetStruct &value) {
  return value.toDynamic();
}
#endif

struct RNCTPWebViewMenuItemsStruct {
  std::string label{};
  std::string key{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNCTPWebViewMenuItemsStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["label"] = label;
    result["key"] = key;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewMenuItemsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_label = map.find("label");
  if (tmp_label != map.end()) {
    fromRawValue(context, tmp_label->second, result.label);
  }
  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
}

static inline std::string toString(const RNCTPWebViewMenuItemsStruct &value) {
  return "[Object RNCTPWebViewMenuItemsStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewMenuItemsStruct &value) {
  return value.toDynamic();
}
#endif

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCTPWebViewMenuItemsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCTPWebViewMenuItemsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCTPWebViewBasicAuthCredentialStruct {
  std::string username{};
  std::string password{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNCTPWebViewBasicAuthCredentialStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["username"] = username;
    result["password"] = password;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewBasicAuthCredentialStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_username = map.find("username");
  if (tmp_username != map.end()) {
    fromRawValue(context, tmp_username->second, result.username);
  }
  auto tmp_password = map.find("password");
  if (tmp_password != map.end()) {
    fromRawValue(context, tmp_password->second, result.password);
  }
}

static inline std::string toString(const RNCTPWebViewBasicAuthCredentialStruct &value) {
  return "[Object RNCTPWebViewBasicAuthCredentialStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewBasicAuthCredentialStruct &value) {
  return value.toDynamic();
}
#endif

struct RNCTPWebViewNewSourceHeadersStruct {
  std::string name{};
  std::string value{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNCTPWebViewNewSourceHeadersStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["name"] = name;
    result["value"] = value;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewNewSourceHeadersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_name = map.find("name");
  if (tmp_name != map.end()) {
    fromRawValue(context, tmp_name->second, result.name);
  }
  auto tmp_value = map.find("value");
  if (tmp_value != map.end()) {
    fromRawValue(context, tmp_value->second, result.value);
  }
}

static inline std::string toString(const RNCTPWebViewNewSourceHeadersStruct &value) {
  return "[Object RNCTPWebViewNewSourceHeadersStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewNewSourceHeadersStruct &value) {
  return value.toDynamic();
}
#endif

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCTPWebViewNewSourceHeadersStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCTPWebViewNewSourceHeadersStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCTPWebViewNewSourceStruct {
  std::string uri{};
  std::string method{};
  std::string body{};
  std::vector<RNCTPWebViewNewSourceHeadersStruct> headers{};
  std::string html{};
  std::string baseUrl{};

#ifdef RN_SERIALIZABLE_STATE
  bool operator==(const RNCTPWebViewNewSourceStruct&) const = default;

  folly::dynamic toDynamic() const {
    folly::dynamic result = folly::dynamic::object();
    result["uri"] = uri;
    result["method"] = method;
    result["body"] = body;
    result["headers"] = ::facebook::react::toDynamic(headers);
    result["html"] = html;
    result["baseUrl"] = baseUrl;
    return result;
  }
#endif
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCTPWebViewNewSourceStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_uri = map.find("uri");
  if (tmp_uri != map.end()) {
    fromRawValue(context, tmp_uri->second, result.uri);
  }
  auto tmp_method = map.find("method");
  if (tmp_method != map.end()) {
    fromRawValue(context, tmp_method->second, result.method);
  }
  auto tmp_body = map.find("body");
  if (tmp_body != map.end()) {
    fromRawValue(context, tmp_body->second, result.body);
  }
  auto tmp_headers = map.find("headers");
  if (tmp_headers != map.end()) {
    fromRawValue(context, tmp_headers->second, result.headers);
  }
  auto tmp_html = map.find("html");
  if (tmp_html != map.end()) {
    fromRawValue(context, tmp_html->second, result.html);
  }
  auto tmp_baseUrl = map.find("baseUrl");
  if (tmp_baseUrl != map.end()) {
    fromRawValue(context, tmp_baseUrl->second, result.baseUrl);
  }
}

static inline std::string toString(const RNCTPWebViewNewSourceStruct &value) {
  return "[Object RNCTPWebViewNewSourceStruct]";
}

#ifdef RN_SERIALIZABLE_STATE
static inline folly::dynamic toDynamic(const RNCTPWebViewNewSourceStruct &value) {
  return value.toDynamic();
}
#endif
class RNCTPWebViewProps final : public ViewProps {
 public:
  RNCTPWebViewProps() = default;
  RNCTPWebViewProps(const PropsParserContext& context, const RNCTPWebViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool allowFileAccess{false};
  bool allowsProtectedMedia{false};
  bool allowsFullscreenVideo{false};
  RNCTPWebViewAndroidLayerType androidLayerType{RNCTPWebViewAndroidLayerType::None};
  RNCTPWebViewCacheMode cacheMode{RNCTPWebViewCacheMode::LOAD_DEFAULT};
  bool domStorageEnabled{false};
  std::string downloadingMessage{};
  bool forceDarkOn{false};
  bool geolocationEnabled{false};
  std::string lackPermissionToDownloadMessage{};
  std::string messagingModuleName{};
  int minimumFontSize{0};
  RNCTPWebViewMixedContentMode mixedContentMode{RNCTPWebViewMixedContentMode::Never};
  bool nestedScrollEnabled{false};
  std::string overScrollMode{};
  bool saveFormDataDisabled{false};
  bool scalesPageToFit{false};
  bool setBuiltInZoomControls{false};
  bool setDisplayZoomControls{false};
  bool setSupportMultipleWindows{false};
  int textZoom{0};
  bool thirdPartyCookiesEnabled{false};
  bool hasOnScroll{false};
  std::string allowingReadAccessToURL{};
  bool allowsBackForwardNavigationGestures{false};
  bool allowsInlineMediaPlayback{false};
  bool allowsPictureInPictureMediaPlayback{false};
  bool allowsAirPlayForMediaPlayback{false};
  bool allowsLinkPreview{false};
  bool automaticallyAdjustContentInsets{false};
  bool autoManageStatusBarEnabled{false};
  bool bounces{false};
  RNCTPWebViewContentInsetStruct contentInset{};
  RNCTPWebViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior{RNCTPWebViewContentInsetAdjustmentBehavior::Never};
  RNCTPWebViewContentMode contentMode{RNCTPWebViewContentMode::Recommended};
  RNCTPWebViewDataDetectorTypesMask dataDetectorTypes{static_cast<RNCTPWebViewDataDetectorTypesMask>(RNCTPWebViewDataDetectorTypes::PhoneNumber)};
  double decelerationRate{0.0};
  bool directionalLockEnabled{false};
  bool enableApplePay{false};
  bool hideKeyboardAccessoryView{false};
  bool keyboardDisplayRequiresUserAction{false};
  bool limitsNavigationsToAppBoundDomains{false};
  RNCTPWebViewMediaCapturePermissionGrantType mediaCapturePermissionGrantType{RNCTPWebViewMediaCapturePermissionGrantType::Prompt};
  bool pagingEnabled{false};
  bool pullToRefreshEnabled{false};
  bool refreshControlLightMode{false};
  bool scrollEnabled{false};
  bool sharedCookiesEnabled{false};
  bool textInteractionEnabled{false};
  bool useSharedProcessPool{false};
  std::vector<RNCTPWebViewMenuItemsStruct> menuItems{};
  std::vector<std::string> suppressMenuItems{};
  bool hasOnFileDownload{false};
  bool fraudulentWebsiteWarningEnabled{false};
  bool allowFileAccessFromFileURLs{false};
  bool allowUniversalAccessFromFileURLs{false};
  std::string applicationNameForUserAgent{};
  RNCTPWebViewBasicAuthCredentialStruct basicAuthCredential{};
  bool cacheEnabled{false};
  bool incognito{false};
  std::string injectedJavaScript{};
  std::string injectedJavaScriptBeforeContentLoaded{};
  bool injectedJavaScriptForMainFrameOnly{false};
  bool injectedJavaScriptBeforeContentLoadedForMainFrameOnly{false};
  bool javaScriptCanOpenWindowsAutomatically{false};
  bool javaScriptEnabled{false};
  bool webviewDebuggingEnabled{false};
  bool mediaPlaybackRequiresUserAction{false};
  bool messagingEnabled{false};
  bool hasOnOpenWindowEvent{false};
  bool showsHorizontalScrollIndicator{false};
  bool showsVerticalScrollIndicator{false};
  RNCTPWebViewNewSourceStruct newSource{};
  std::string userAgent{};
  std::string injectedJavaScriptObject{};

  #ifdef RN_SERIALIZABLE_STATE
  ComponentName getDiffPropsImplementationTarget() const override;

  folly::dynamic getDiffProps(const Props* prevProps) const override;
  #endif
};

} // namespace facebook::react
